from datetime import datetime, timedelta
from functools import reduce

from models import CookedDish
from models.ID import ID


class Bestellung(ID):
    def __init__(self, id_: int, customerID: int, itemIDs: list[int], totalPrice: int, timeStamp: str):
        super().__init__(id_)
        self.__customerID = customerID
        self.__itemIDs = itemIDs
        self.__totalPrice = totalPrice
        self.__timeStamp = timeStamp

    def __eq__(self, other):
        return self.__customerID == other.__customerID and self.__itemIDs == other.__itemIDs

    def __str__(self):
        return super().__str__() + f", Kunden-ID = '{self.__customerID}', Artikel = '{self.__itemIDs}', Gesamtkosten = '{self.__totalPrice}'"

    def __hash__(self):
        return hash(self.__str__())

    @property
    def customerID(self):
        return self.__customerID

    @customerID.setter
    def customerID(self, customerID):
        self.__customerID = customerID

    @property
    def itemIDs(self):
        return self.__itemIDs

    @itemIDs.setter
    def itemIDs(self, itemIDs):
        self.__itemIDs = itemIDs

    @property
    def totalPrice(self):
        return self.__totalPrice

    @totalPrice.setter
    def totalPrice(self, totalPrice):
        self.__totalPrice = totalPrice

    @property
    def timeStamp(self):
        return self.__timeStamp

    @timeStamp.setter
    def timeStamp(self, timeStamp):
        self.__timeStamp = timeStamp

    def createTimeStamp(self):
        """
        Method for creating the timestamp of this Order (as a string in iso format)
        """
        self.__timeStamp = datetime.now().isoformat()

    def computeEstimatedDeliveryTime(self, dishes: list[CookedDish]):
        """
        Returns the estimated time of delivery for the current order
        :param dishes: The list of cooked dishes present in this order, as drinks don't have a prep_time
        """
        maxPrepTime = max(dishes, key=lambda dish: dish.prep_time).prep_time
        etd = datetime.fromisoformat(self.__timeStamp) + timedelta(minutes=int(maxPrepTime))
        return etd.isoformat()

    def computeTotalPrice(self, items):
        """
        Adds up the prices from the items list
        :returns: Total order price
        """
        # items[0] = items[0].id
        self.__totalPrice = reduce(lambda a, m: a + int(m.price), items, 0)
        return self.__totalPrice

    def generateBill(self, items):
        """
        Generates and returns a bill, containing the items of this order
        :returns: The bill as a string
        """
        self.computeTotalPrice(items)
        billLines = list(map(lambda item: f"{item.name} " + "." * (30 - len(item.name)) + f" {item.price}", items))
        billLines.append(f"\nGesamtkosten " + '.' * 18 + f" {self.__totalPrice}")

        dishes = []
        for it in items:
            if type(it) == CookedDish:
                dishes.append(it)

        time = datetime.fromisoformat(self.__timeStamp).strftime(" %R ")
        etd = datetime.fromisoformat(self.computeEstimatedDeliveryTime(dishes)).strftime(" %R ")
        billLines.append(f"\nUhrzeit der Bestellung: {time}")
        billLines.append(f"Voraussichtliche Lieferzeit: {etd}")

        return reduce(lambda a, b: a + '\n' + b, billLines)

    def printBill(self, items):
        """
        Prints the bill of this order generated by the __generate_bill method
        """
        print(self.generateBill(items))
